# 小易的升级之路

## 题目描述

小易经常沉迷于网络游戏.有一次,他在玩一个打怪升级的游戏,他的角色的初始能力值为 a.在接下来的一段时间内,他将会依次遇见n个怪物,每个怪物的防御力为b1,b2,b3...bn. 如果遇到的怪物防御力bi小于等于小易的当前能力值c,那么他就能轻松打败怪物,并 且使得自己的能力值增加bi;如果bi大于c,那他也能打败怪物,但他的能力值只能增加bi 与c的最大公约数.那么问题来了,在一系列的锻炼后,小易的最终能力值为多少?

## 输入描述:

```
对于每组数据,第一行是两个整数n(1≤n<100000)表示怪物的数量和a表示小易的初始能力值.
第二行n个整数,b1,b2...bn(1≤bi≤n)表示每个怪物的防御力
```

## 输出描述:

```
对于每组数据,输出一行.每行仅包含一个整数,表示小易的最终能力值
```

示例1

## 输入

复制

```
3 50
50 105 200
5 20
30 20 15 40 100
```

## 输出

复制

```
110
205
```

<https://www.nowcoder.com/practice/fe6c73cb899c4fe1bdd773f8d3b42c3d?tpId=49&&tqId=29329&rp=1&ru=/activity/oj&qru=/ta/2016test/question-ranking>

代码：

```
#include <vector>
#include <iostream>
using  namespace std;

int gcc(int m, int n)
{
	int r = 0;
	while (r = m%n)
	{
		m = n; 
		n = r;
	}
	return n;
}

int Calucate(vector<int>& v, int p)
{
	for (int i = 0; i < v.size(); i++)
	{
		if (p >= v[i])
			p += v[i];
		else
			p += gcc(v[i], p);
	}
	return p;
}

int main()
{
	int n, p;
	while (cin >> n >> p)
	{
		vector<int> v(n);
		for (int i = 0; i < n; i++)
			cin >> v[i];
		int ret = Calucate(v, p);
		cout << ret << endl;
	}
	return 0;
}
```

# 找出字符串中第一个值出现一次的字符

## 题目描述

找出字符串中第一个只出现一次的字符



 

 

 

## 输入描述:

```
输入一个非空字符串
```

## 输出描述:

```
输出第一个只出现一次的字符，如果不存在输出-1
```

示例1

## 输入

复制

```
asdfasdfo
```

## 输出

复制

```
o
```

<https://www.nowcoder.com/practice/e896d0f82f1246a3aa7b232ce38029d4?tpId=37&&tqId=21282&rp=1&ru=/activity/oj&qru=/ta/huawei/question-ranking>

代码：

```
#include <string>
#include <iostream>
using namespace std;

char Find(string& str)
{
	int hashTable[256] = { 0 };
	for (size_t i = 0; i < str.size(); i++)
		hashTable[str[i]]++;
	for (size_t i = 0; i < str.size(); i++)
	{
		if (hashTable[str[i]] == 1)
			return str[i];
	}
    return '\0';
}

int main()
{
	string str;
	while (cin >> str)
	{
		char ch = Find(str);
        if(ch =='\0')
            cout << "-1" << endl;
		else
            cout << ch << endl;
	}
	return 0;
}
```

